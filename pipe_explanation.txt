pipe.c - Full Duplex Inter-Process Communication using Pipes
==============================================================

LINE-BY-LINE EXPLANATION:

Line 1-5: Header files
- stdio.h: Standard I/O (printf, fgets)
- stdlib.h: exit(), EXIT_FAILURE constant
- unistd.h: Unix system calls (pipe, fork, read, write, close)
- string.h: String functions (strlen, strcspn)
- ctype.h: Character checking (isspace)

Line 7: int main()
- Program entry point

Line 8: int fd1[2], fd2[2];
- fd1: First pipe (parent → child communication)
  - fd1[0]: read end
  - fd1[1]: write end
- fd2: Second pipe (child → parent communication)
  - fd2[0]: read end
  - fd2[1]: write end

Line 9: pid_t pid;
- Variable to store process ID from fork()

Line 10: char writeMsg[100], readMsg[100];
- Buffers for messages
- writeMsg: data to send
- readMsg: data to receive

Line 13: if (pipe(fd1) == -1 || pipe(fd2) == -1)
- Creates two pipes
- Returns -1 if creation fails
- Need two pipes for full duplex (bidirectional) communication

Line 14-16: Error handling for pipe creation
- perror(): prints system error message
- exit(EXIT_FAILURE): terminates program with error code

Line 18: pid = fork();
- Creates child process
- Returns 0 to child, child's PID to parent

Line 20-23: Fork error handling
- If fork() returns negative, error occurred
- Print error and exit

Line 26-54: CHILD PROCESS CODE (pid == 0)

Line 27: close(fd1[1]);
- Close write end of fd1 (parent→child pipe)
- Child only needs to READ from fd1

Line 28: close(fd2[0]);
- Close read end of fd2 (child→parent pipe)
- Child only needs to WRITE to fd2

Line 30: read(fd1[0], readMsg, sizeof(readMsg));
- Read message from parent through fd1
- Blocks until data is available
- Reads into readMsg buffer

Line 31: printf("\n[Child] Received from Parent: %s\n", readMsg);
- Display received message

Line 34: int chars = 0, words = 0, lines = 0, in_word = 0;
- Counters for analysis:
  - chars: total characters
  - words: number of words
  - lines: number of lines
  - in_word: flag to track if currently inside a word

Line 35-45: Character/Word/Line counting loop
- Loop through each character in string

Line 36: chars++;
- Count every character

Line 37-38: if (readMsg[i] == '\n') lines++;
- Count newline characters as lines

Line 39-44: Word counting logic
- if (isspace(readMsg[i])): current char is whitespace
  - Set in_word = 0 (not in word anymore)
- else if (!in_word): non-whitespace and not already in word
  - Set in_word = 1 (entering new word)
  - Increment words counter

Line 47: sprintf(writeMsg, "Characters: %d, Words: %d, Lines: %d", chars, words, lines);
- Format analysis results into string
- sprintf works like printf but writes to string

Line 49: write(fd2[1], writeMsg, strlen(writeMsg) + 1);
- Send analysis back to parent through fd2
- strlen(writeMsg) + 1 includes null terminator

Line 50: printf("[Child] Sent analysis back to Parent.\n");
- Confirmation message

Line 52-53: close(fd1[0]); close(fd2[1]);
- Clean up: close file descriptors used by child

Line 54: exit(0);
- Child process terminates

Line 58-74: PARENT PROCESS CODE (pid > 0)

Line 59: close(fd1[0]);
- Close read end of fd1 (parent→child pipe)
- Parent only needs to WRITE to fd1

Line 60: close(fd2[1]);
- Close write end of fd2 (child→parent pipe)
- Parent only needs to READ from fd2

Line 62-63: fgets(writeMsg, sizeof(writeMsg), stdin);
- Prompt user for input
- Read entire line including newline

Line 64: writeMsg[strcspn(writeMsg, "\n")] = '\0';
- Remove trailing newline character
- strcspn finds position of first '\n'
- Replace it with null terminator

Line 66: write(fd1[1], writeMsg, strlen(writeMsg) + 1);
- Send message to child through fd1

Line 67: printf("[Parent] Sent message to Child.\n");
- Confirmation

Line 69: read(fd2[0], readMsg, sizeof(readMsg));
- Read analysis results from child through fd2
- BLOCKS until child sends data

Line 70: printf("[Parent] Received from Child: %s\n", readMsg);
- Display analysis received from child

Line 72-73: close(fd1[1]); close(fd2[0]);
- Clean up: close file descriptors used by parent

Line 76: return 0;
- Parent terminates

PIPE COMMUNICATION EXPLAINED:
==============================

FULL DUPLEX = Two-way communication
- fd1: Parent writes → Child reads
- fd2: Child writes → Parent reads

PIPE STRUCTURE:
Each pipe has two ends:
- Read end [0]: for reading data
- Write end [1]: for writing data

Data flow is unidirectional in each pipe:
fd1: [Parent writes to fd1[1]] → [Child reads from fd1[0]]
fd2: [Child writes to fd2[1]] → [Parent reads from fd2[0]]

WHY CLOSE UNUSED ENDS?
=======================
1. Prevents confusion
2. Saves file descriptors (limited resource)
3. Allows proper EOF detection
4. Good practice for clean code

EXECUTION FLOW:
===============

Parent Process                      Child Process
--------------                      -------------
Create fd1 and fd2 pipes
fork() → creates child
                                    fork() returns 0
Close fd1[0], fd2[1]                Close fd1[1], fd2[0]
Prompt user for input               
Read input: "Hello World"           
Write to fd1[1]                     Read from fd1[0]
                                    Receive: "Hello World"
                                    Count: chars=11, words=2, lines=0
                                    Format result string
                                    Write to fd2[1]
Read from fd2[0] (blocks)           exit(0)
Receive: "Characters: 11, Words: 2, Lines: 0"
Print result
Close pipes
exit

WORD COUNTING ALGORITHM:
========================
Example: "Hello World"

H: not space, !in_word → in_word=1, words=1
e,l,l,o: not space, in_word → continue
(space): is space → in_word=0
W: not space, !in_word → in_word=1, words=2
o,r,l,d: not space, in_word → continue

Result: 2 words

EXAMPLE RUN:
============
Input: "Hello World"

Output:
Enter a string (or sentence): Hello World
[Parent] Sent message to Child.

[Child] Received from Parent: Hello World
[Child] Sent analysis back to Parent.
[Parent] Received from Child: Characters: 11, Words: 2, Lines: 0

PLATFORM NOTE:
==============
- Linux/Unix ONLY
- Uses pipe() and fork() system calls
- Not available on Windows natively
- Use WSL (Windows Subsystem for Linux) to run
